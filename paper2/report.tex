\documentclass[sigconf]{acmart}

\input{format/i523}

\graphicspath{ {images/} }

\usepackage{listings}

\lstset{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\title{Mini Project: ESP8266 And Raspberry Pi Robot Car}

\author{Mani Kumar Kagita}
\affiliation{%
  \institution{Indiana University}
  \streetaddress{107 S. Indiana Avenue}
  \city{Bloomington} 
  \state{Indiana} 
  \postcode{43017-6221}
}
\email{mkagita@iu.edu}


\begin{abstract}
Robotics is the fastest and emerging field in modern world. By providing sufficient intelligence to an autonomous driving robot, it must be able to detect the obstacles coming in its path and avoid them. Ultrasonic distance sensors provide data to autonomously detect obstacles and avoid in an unstructured environment without having human guidance. A 3 wheeled, two gear motors are used to build the Autonomous Intelligent Robot which is controlled using ESP8266 controller and Raspberry Pi. An Arduino program is constructed in ESP8266 NodeMCU board that can produce a multi-angle movement for the Robot to freely move in all directions and choose directions to turn based on the detected obstacles. 

\end{abstract}

\keywords{Raspberry Pi, Robot Car, ESP8266 NodeMCU, I523, HID319}

\maketitle

\section{Introduction}
Robotics is the branch of technology dealing with the design of program, construction, operation, maintenance and design application of robots. A machine capable of automatically carrying out a multi complex series of actions, especially the one programmable by a computer is defined as a robot. 

A Robot car is a electro-mechanical machine which is usually guided by a computer program and electronic devices. The main objective of any autonomous robot car is to be navigated in any structured or unstructured environments by avoiding obstacles and prevent collisions. 
Collision avoidance is the process in preventing a vehicle from colliding with any other vehicle or object. And, Obstacle avoidance refers to the ability of a robot to detect obstacles in its way if there are any and thus make its own obstacle free path.

To be effective, the distance from robot car to the obstacle should be constantly measured in real-time as position of autonomous robot car changes with the time.
Proximity ultrasonic distance measuring sensors are integrated to robot car so as to determine the distance to an object. When an obstacle is detected, robot car will start measuring right side and left side proximity using ultrasonic sensors and provide data to micro-controller. Comparing the longest distance from right to that of left, micro-controller will navigate robot car to choose best path. ESP8266 NodeMCU is the micro-controller used here that navigates the robot over wifi. Also a computer program can be remotely sent to this module using wifi instead of connecting USB cable to laptop. The main advantage of robot car is to stream live videos to the user over wifi and also for security purposes when added a camera to it.

\section{Existing System}
In a general robotic systems, a simple steering algorithm is used for controlling robot actions by a human using a infrared remote control. The driver will be monitoring the obstacles and navigate the robot accordingly. Robot car will get the instructions from infrared signal obtained from remote control and follow the directions.

\section{Proposed System}
The main objective is to navigate autonomous robot car without using any external remote controller for controlling robot movements. Based on the intelligence provided to the robot car, it will auto detect the obstacles present in its own path using ultrasonic sensors, taking decision to avoid them based on the code written in micro-controller.

\section{COLLISION AVOIDANCE}
Collision avoidance is said to be one of the driving factors for the design of robot cars. A collision avoidance systems is designed to reduce the collision severity which is also know as pre-crash system or forward collision warning system. Proximity sensors will send data to the robot car on the distance to obstacle. Once the obstacle is detected, robot  car will autonomously take action by halting its movement and check for the direction which is feasible for it to move \cite{stratis2009}. 

\section{System Architecture}
System Architecture consists of following blocks :
\begin{description}
    \item[$\bullet$] Raspberry Pi

    \item[$\bullet$] ESP8266 NodeMCU 

    \item[$\bullet$] 3 wheel Robot Car kit

    \item[$\bullet$] L298N DC Stepper Motor Drive Controller 

    \item[$\bullet$] 12v and 5v DC batteries
    
    \item[$\bullet$] Ultrasonic Distance Measuring Sensor Module 
    
\end{description}

The Mechanical design of the Robot car includes hardware such as motor and wheel placement and body setup. Robot car uses two gear-motors attached to wheels and one free wheel for forward, backward, left and right movements. Free wheel ball is placed at rear side of the robot which helps for 360 degrees free movement. L298N DC Stepper Motor Drive controller is used to control the speed and direction of the two gear motor wheels. Ultrasonic sensors are placed at front side of the robot which is capable to detect the objects on its path.

\begin{figure}[htb]
      \includegraphics[width=\columnwidth]{images/FlowDiagram.png}
      \caption{Data Flow Diagram}
\end{figure}

\section{System, Software and Hardware Requirements}
\subsection{Platform Requirement}
\subsubsection{Raspbian Operating System}
\begin{description}
\item[$\bullet$] Raspbian is a open-source operating system based on Debian which is optimized for Raspberry Pi hardware. This operating system comes with 35000 inbuilt packages, pre-compiled software for easy installation on Raspberry Pi.
\end{description}

\subsection{Software Requirement}
The Software Requirements for designing Robot car includes:
1. JDK
2. Arduino IDE

\subsubsection{JDK : Java Platform (JDK)}
The Java Development Kit (JDK) is an implementation
of either one of the Java SE, Java EE or Java ME platforms released by Oracle Corporation in the form of a binary product aimed at Java developers on Solaris, Linux, Mac OS X or Windows. The JDK includes a private JVM and a few other resources to finish the recipe to a Java Application.

\subsubsection{Arduino IDE}
Arduino IDE tool. This open-source tool allows to write programs and uploaded into any arduino supported boards. It can be operated in two ways. If there is a reliable internet connection, Ardiono Web Editor (online IDE) can be used allowing to save the sketches to store in the cloud and having them available from any type of device and to have a good backup. For offline works, Desktop IDE can be used ~\cite{arduino2015}. To program into ESP8266 NodeMCU, Ardiono IDE is installed on Raspberry Pi to check the code and loads it into ESP8266 board.

\subsection{HARDWARE REQUIREMENT}
The Hardware components required for our project are Min 1 GB of RAM,10 GB HDD, Dual core processor for the machine on which development will be done, Robot kit, IP Camera, Bluetooth Module etc for developing the robot.

Hardware Requirement
\begin{description}
\item[a)] Raspberry Pi
\item[c)] ESP8266 NodeMCU micro-controller
\item[c)] L298 Stepper Motor Driver Controller
\item[d)] DC power supply 12v and 5v
\item[e)] Robot Car chassis kit
\item[f)] Ultrasonic sensor
\item[g)] Wires, Breadboard, Small PCB.
\end{description}

\section{Basic Design of the Robot}
Robot car is built with ESP8266 NodeMCU microcontroller on which programming code is written to control the navigation. ESP8266 is connected with two wheel DC motors through L298 stepper motor driver controller(pins IN1, IN2, IN3, IN4) which provides electric power to the motors. Wheel actuators are used to move robot in different directions(forward, backward, right, left and stop).
A brief description of input pins is given below.
\begin{description}
    \item[$\bullet$] RightMotorForward  : 13  (GPIO15(D8)->IN1)
    \item[$\bullet$] RightMotorBackward : 15 (GPIO13(D7)->IN2)
    \item[$\bullet$] LeftMotorForward   : 0    (GPIO2(D4)->IN3)
    \item[$\bullet$] LeftMotorBackward  : 2   (GPIO0(D3)->IN4)
    \item[$\bullet$] RightMotorENB      : 14 (GPIO14(D5)->Motor-A Enable)
    \item[$\bullet$] LeftMotorENB       : 12  (GPIO12(D6)->Motor-B Enable)
\end{description}

Table below represent input pins for movement of Robot in different directions.

\begin{center}
\begin{tabular}{ | c | c| c | c| c | } 
\hline
Movement & Pin 14 & Pin 12 & Pin 13 & Pin 15 \\ 
\hline
Forward & 1 & 0 & 1 & 0 \\ 
\hline
Backward & 0 & 1 & 0 & 1 \\
\hline
Left & 1 & 0 & 0 & 1 \\
\hline
Right & 0 & 1 & 1 & 0 \\
\hline
Stop  & 0 & 0 & 0 & 0 \\
\hline

\end{tabular}
\end{center}

The movement of robot car will stop once an obstacle is detected along its path which can be detected by an ultrasonic sensors. Then the sensor will look for the best path to navigate based on the right side and left side distances received from the sensor.

\subsection{Ultrasonic Sensors for Obstacle Avoidance}
Ultrasonic sensors are typically used as part of Computer Vision, Sonar. These are used to provides precise and non-contact distance measurements in its view within a 3 centimeters to 400 centimeters range. Ultrasonic sensors work in any lighting condition environments, making a good alternative to supplement infrared object detectors.
Working Principle: The ultrasonic sensor emits a high frequency and short range signals. These signals travel in air at the speed of velocity of sound. If the signal is hit to any obstacle, then it will reflect back the echo signal to the sensor. A multi-vibrator is fixed to the base of an ultrasonic sensor. It`s the combination of a vibrator and a resonator. The working principle of resonator is to  deliver the  ultrasonic wave generated by the vibration from the vibrator. The ultrasonic sensor consists of two parts; the emitter which produces a 40 kHz sound wave and detector detects 40 kHz sound wave and sends electrical signal back to the micro-controller ~\cite{ijedr2016}.
\section{Code}
\begin{lstlisting}
/* include library */
#include <ESP8266WiFi.h>
#include <Servo.h> 
#include <NewPing.h>

/* define port */
WiFiClient client;
WiFiServer server(80);

#define SONAR_SERVO_PIN 16
#define TRIGGER_PIN     5
#define ECHO_PIN        4

#define MAX_DISTANCE    200
/* WIFI settings */
const char* ssid = "virusdetected";
const char* password = "HemaMunna424$$";

/* data received from application */
String  data =""; 

/* define L298N motor control pins */
int rightMotorForward = 12;  /*GPIO14(D5)->IN1*/
int rightMotorBackward = 14; /*GPIO12(D6)->IN2*/
int leftMotorForward = 15;    /*GPIO13(D7)->IN3*/
int leftMotorBackward = 13;   /*GPIO15(D8)->IN4*/



/* define L298N enable pins */
int rightMotorENB = 0; /*GPIO0(D3)->Motor-A Enable*/
int leftMotorENB = 2;  /*GPIO2(D4)->Motor-B Enable*/

NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE);
Servo myServo;

const int triggerDistance = 25;

// Variables
unsigned int time1; // to store how long it takes for the ultrasonic wave to come back
int distance;       // to store the distance calculated from the sensor
int fDistance;  // to store the distance in front of the robot
int lDistance;  // to store the distance on the left side of the robot
int rDistance;  // to store the distance on the right side of the robot


char dist[3];
char rot[3];
int rotation = 0;
String output = "";

void connectWiFi()
{
  Serial.println("Connecting to WIFI");
  WiFi.begin(ssid, password);
  while ((!(WiFi.status() == WL_CONNECTED)))
  {
    delay(300);
    Serial.print("..");
  }
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("NodeMCU Local IP is : ");
  Serial.print((WiFi.localIP()));
}

void scan(int deg)
{
  myServo.write(deg);
  delay(10);

  int time1 = sonar.ping();
  distance = time1 / US_ROUNDTRIP_CM;
  delay(10);
  if(distance <= 0){
    distance = triggerDistance;
  }

  delay(30);
} 

/*** FORWARD ***/
void MotorForward(void)   
{
  digitalWrite(leftMotorENB,HIGH);
  digitalWrite(rightMotorENB,HIGH);
  digitalWrite(leftMotorForward,HIGH);
  digitalWrite(rightMotorForward,HIGH);
  digitalWrite(leftMotorBackward,LOW);
  digitalWrite(rightMotorBackward,LOW);
}

/*** BACKWARD ***/
void MotorBackward(void)   
{
  digitalWrite(leftMotorENB,HIGH);
  digitalWrite(rightMotorENB,HIGH);
  digitalWrite(leftMotorBackward,HIGH);
  digitalWrite(rightMotorBackward,HIGH);
  digitalWrite(leftMotorForward,LOW);
  digitalWrite(rightMotorForward,LOW);
}

/*** TURN LEFT ***/
void TurnLeft(void)   
{
  digitalWrite(leftMotorENB,HIGH);
  digitalWrite(rightMotorENB,HIGH); 
  digitalWrite(leftMotorForward,HIGH);
  digitalWrite(rightMotorForward,LOW);
  digitalWrite(rightMotorBackward,LOW);
  digitalWrite(leftMotorBackward,HIGH);  
}

/*** TURN RIGHT***/
void TurnRight(void)   
{
  digitalWrite(leftMotorENB,HIGH);
  digitalWrite(rightMotorENB,HIGH);
  digitalWrite(leftMotorForward,HIGH);
  digitalWrite(rightMotorForward,LOW);
  digitalWrite(rightMotorBackward,HIGH);
  digitalWrite(leftMotorBackward,LOW);
}

/*** STOP ***/
void MotorStop(void)   
{
  digitalWrite(leftMotorENB,LOW);
  digitalWrite(rightMotorENB,LOW);
  digitalWrite(leftMotorForward,LOW);
  digitalWrite(leftMotorBackward,LOW);
  digitalWrite(rightMotorForward,LOW);
  digitalWrite(rightMotorBackward,LOW);
}

/*** RECEIVE DATA FROM the APP ***/
String checkClient (void)
{
  while(!client.available()) delay(1); 
  String request = client.readStringUntil('\r');
  request.remove(0, 5);
  request.remove(request.length()-9,9);
  return request;
}

void setup()
{
  Serial.begin(115200);
  connectWiFi();
  server.begin();

  pinMode(TRIGGER_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  myServo.attach(SONAR_SERVO_PIN);  // Attaches the Servo to the Servo Object 
  /* initialize motor control pins as output */
  pinMode(leftMotorForward, OUTPUT);
  pinMode(rightMotorForward, OUTPUT); 
  pinMode(leftMotorBackward, OUTPUT);  
  pinMode(rightMotorBackward, OUTPUT);

  /* initialize motor enable pins as output */
  pinMode(leftMotorENB, OUTPUT); 
  pinMode(rightMotorENB, OUTPUT);

  /* start server communication */
}

void loop()
{
  
  scan(90);                                //Get the distance retrieved
  fDistance = distance;
  if(fDistance < triggerDistance){
    MotorBackward();
    delay(682); 
    MotorStop();
    scan(170);
    delay(600);
    lDistance = distance;
    scan(3);
    delay(600);
    rDistance = distance;
   if(lDistance < rDistance){
      TurnRight();
      delay(682);
      MotorStop();
      MotorForward();
    }
    else{
      TurnLeft();
      delay(682);
      MotorStop();
      MotorForward();
    }
  }
  else{
    MotorForward();
  } 
}


\end{lstlisting}

\section{Application}
1. Scientific
2. Space Probes
3. Submarines
4. Military and Law Enforcement
5. Recreation and Hobby

\section{Conclusion}
In these modern days, long distance communication is a crucial theory of controlling things from internet and this leads a for a vast application areas. Obstacle avoidance robot can be controlled by wifi which can track the obstacles along its path way and can be easily controlled remotely.

\begin{acks}

The authors would like to thank Dr. Gregor von Laszewski for his support and suggestions in writing this paper.

\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{report} 

\end{document}
